# -*- coding: utf-8 -*-
"""NASA_Space_Apps_Challenge_Data_Analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rCM30jChMsVaANAM9YGhP7SM-Z-69XXF

## Imports and Installations
"""

#Imports
import numpy as np
import pandas as pd
import math
import requests
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sodapy import Socrata
from io import StringIO
import datetime as dt
import meteomatics.api as api

!pip install sodapy

!pip install requests

!pip install meteomatics

"""## API Connections

### NASA FIRMS

Connecting the database on real time fire data from NASA FIRMS.

Instructions: input information below based on the parameters from the last active session on the FIRMS API.

Access to the API key: [API Key](https://https://firms.modaps.eosdis.nasa.gov/api/)
"""

api_key = '8e32c5e1a58133ddf186114abfe0f3d2'

url = 'https://firms.modaps.eosdis.nasa.gov/api/country/csv/8e32c5e1a58133ddf186114abfe0f3d2/VIIRS_NOAA20_NRT/USA/1/2023-10-07'

params = {
    'api_key': api_key,
    'source': 'VIIRS_NOAA20_NRT',  # Example latitude (replace with your own)
    'country_code': 'USA',  # Example longitude (replace with your own)
    'day_range': '7',  # Example start date in YYYYMMDD format
    'date': '2023-10-07'    # Example end date in YYYYMMDD format
}

response = requests.get(url)

# Check if the request was successful
if response.status_code == 200:
    # Print the first few lines of the CSV data
      # Adjust the number to display more or fewer characters

    try:
        # Parse the CSV data into a Pandas DataFrame
        firms_df = pd.read_csv(StringIO(response.text))

        # Print the DataFrame
        print(firms_df.head())
    except pd.errors.ParserError as e:
        print(f"ParserError: {e}")
else:
    # Print an error message if the request was not successful
    print(f"Error: {response.status_code}")

firms_df

"""## Streetlights Data - Socrata

Community-based database of streetlights in San Francisco.

**Edits to original:** addition of two columns on latitude and longitude, extracted from object contained in the feature 'point'.
"""

# Unauthenticated client only works with public data sets. Note 'None'
# in place of application token, and no username or password:
client = Socrata("data.sfgov.org", None)

# Example authenticated client (needed for non-public datasets):
# client = Socrata(data.sfgov.org,
#                  MyAppToken,
#                  username="user@example.com",
#                  password="AFakePassword")

# First 2000 results, returned as JSON from API / converted to Python list of
# dictionaries by sodapy.
results = client.get("6tt8-ugnj", limit=2000)

# Convert to pandas DataFrame
streetlights_df = pd.DataFrame.from_records(results)
streetlights_df[['latitude', 'longitude']] = streetlights_df['point'].apply(lambda x: pd.Series([x['latitude'], x['longitude']]))

"""## Meteomatics - Live Weather Information"""

# Authentication
username = 'fundacaoestudar_oliveiralevayreis_marina'
password = 'A4c3kAS9l3'

# Params
coordinates = [(37.7790262, -122.419906)]
parameters = ['t_2m:C', 'msl_pressure:hPa', 'precip_24h:mm', 'wind_speed_10m:ms', 'weather_symbol_24h:idx']
model = 'mix'
startdate = dt.datetime.utcnow().replace(minute=0, second=0, microsecond=0)
enddate = startdate + dt.timedelta(days=10)
interval = dt.timedelta(hours=24)

# Call to API
meteomatics_df = api.query_time_series(coordinates, startdate, enddate, interval, parameters, username, password, model=model)
wind_speed = meteomatics_df['wind_speed_10m:ms']
precipitation = meteomatics_df['precip_24h:mm']

meteomatics_df

"""## Distance Calculation and Management

Calculating distance based on latitude and longitude considering the Haversine Distance formula.
"""

from math import radians, sin, cos, sqrt, atan2, inf, e, log

def haversine_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the Haversine distance between two points on the Earth's surface.

    Parameters:
    - lat1, lon1: Latitude and longitude of point 1 in degrees
    - lat2, lon2: Latitude and longitude of point 2 in degrees

    Returns:
    - Distance in kilometers
    """
    # Radius of the Earth in Km
    R = 6371.0

    # Convert latitude and longitude from degrees to radians
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])

    # Differences in coordinates
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Haversine formula
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))

    # Distance in Km
    distance = R * c

    return round(distance)

"""## Coordinates to Radians

### Street Lights
"""

# Convert latitude and longitude columns to float, handle NaN values
streetlights_df['latitude'] = pd.to_numeric(streetlights_df['latitude'], errors='coerce')
streetlights_df['longitude'] = pd.to_numeric(streetlights_df['longitude'], errors='coerce')

# Drop rows with NaN values
streetlights_df = streetlights_df.dropna(subset=['latitude', 'longitude'])

# Convert latitude and longitude to radians element-wise
streetlights_df['latitude_rad'] = streetlights_df['latitude'].apply(radians)
streetlights_df['longitude_rad'] = streetlights_df['longitude'].apply(radians)

"""### FIRMS Active Fire Data"""

# Convert latitude and longitude columns to float, handle NaN values
firms_df['latitude'] = pd.to_numeric(firms_df['latitude'], errors='coerce')
firms_df['longitude'] = pd.to_numeric(firms_df['longitude'], errors='coerce')

# Drop rows with NaN values
firms_df = firms_df.dropna(subset=['latitude', 'longitude'])

# Convert latitude and longitude to radians element-wise
firms_df['latitude_rad'] = firms_df['latitude'].apply(radians)
firms_df['longitude_rad'] = firms_df['longitude'].apply(radians)

firms_df

streetlights_df['streetlight_id'] = range(len(streetlights_df))

streetlights_df['latitude'].max()

firms_df['fire_id'] = range(len(firms_df))

firms_df

"""## Functions for Danger Zones

### Z-Value
"""

def z_value(distance_fire_street_lights, wind_speed, precipitation):
  z = 1000*((2**(1/distance_fire_street_lights) * 1 + wind_speed)/(math.log(math.e + precipitation)-1))
  return round(z, 2)

"""### Danger Level"""

def danger_level(z_value):
  if z_value < 10:
    return 1
  elif z_value >= 10 and z_value < 14:
    return 2
  elif z_value >= 14 and z_value < 24:
    return 3
  elif z_value >= 24 and z_value < 70:
    return 4
  elif z_value >= 70:
    return 5

"""## Streetlight Database with Danger Level Data"""

# Initialize variables and data structures
data = {}
requests = 0
smallest_distances = []
fire_ids = []
streetlight_ids = []
smallest_distance = math.inf

# Loop over streetlights and fire incidents
for lat_rad_sl, lat_sl, long_rad_sl, long_sl, streetlight_id in zip(streetlights_df['latitude_rad'], streetlights_df['latitude'], streetlights_df['longitude_rad'], streetlights_df['longitude'], streetlights_df['streetlight_id']):

  # Increment the request counter, considering API limitations
  requests += 1

  # Check if the number of requests is within the limit
  if requests < 50:
    meteomatics_df = api.query_time_series([(lat_sl, long_sl)], startdate, enddate, interval, parameters, username, password, model=model)

  # Loop over fire incidents
  for lat_rad_fire, long_rad_fire, fire_id in zip(firms_df['latitude_rad'], firms_df['longitude_rad'], firms_df['fire_id']):

    # Calculate the Haversine distance between streetlight and fire incident
    curr_distance = haversine_distance(lat_rad_sl, long_rad_sl, lat_rad_fire, long_rad_fire)

    # Update the smallest distance if the current distance is smaller
    if curr_distance > 0 and curr_distance < smallest_distance:
      smallest_distance = curr_distance

  # Append data to lists
  smallest_distances.append(smallest_distance)
  fire_ids.append(fire_id)
  streetlight_ids.append(streetlight_id)

  # Reset smallest distance for the next streetlight
  smallest_distance = math.inf

# Create a dictionary to store the data
data['smallest_distances:m'] = smallest_distances
data['fire_ids'] = fire_ids
data['streetlight_ids'] = streetlight_ids

# Sample wind speed and precipitation data from the meteomatics dataframe
data['wind_speed_10m:ms'] = meteomatics_df['wind_speed_10m:ms'].sample(n=len(streetlights_df), replace=True)
data['precipitation_24h:mm'] = meteomatics_df['precip_24h:mm'].sample(n=len(streetlights_df), replace=True)

# Create a Pandas DataFrame from the dictionary
intermediate_df = pd.DataFrame(data)

# Dropping previous indexes from the Meteomatics database
intermediate_df = intermediate_df.reset_index(drop=True)
intermediate_df

#Including new parameters to the intermediate database
intermediate_df['z-value'] = intermediate_df.apply(lambda row: z_value(row['smallest_distances'], row['wind_speed'], row['preicipitation']), axis = 1)
intermediate_df['danger_level'] = intermediate_df.apply(lambda row: row['danger_level'])
intermediate_df

streetlights_with_fire_weather_data = pd.merge(streetlights_df, intermediate_df, how='inner', on='streetlight_ids')

streetlights_with_fire_weather_data